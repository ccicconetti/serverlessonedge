# SSL/TLS gRPC support

Client/server authentication can be enabled in all the executables with `--secure`.
When the command-line flag is present, the client authenticates with the server and their communications are encrypted using SSL/TLS.
Note this applies **only** to the data path, i.e., to the invocation of lambda functions, not the interactions between the controller and other components or any other gRPC interface.

SSL/TLS support should be considered experimental and highly insecure and it is never to be used in production systems, but only in research experiments with no sensitive data for the purpose of evaluating the performance of such protocols,in terms of (e.g.) latency and traffic overhead).

We will use the following components:

- `edgecomputer`: lambda function executor
- `edgeclient`: lambda function consumer
- `edgerouter`: forward lambda calls from `edgeclient` to `edgecomputer`
- `edgecontroller`: registers `edgecomputer` on `edgerouter`

After building the codebase (see [BUILDING.md](BUILDING.md)), chdir to the directory containing the executables, e.g., if compile in debug mode:

```
cd build/debug/Executables/
```

## Generate certificates

First, we need X.509 certificates and keys, for the server and client, as well as a root certificate.
The keys must not be password-protected.
A script is bundled in the repository to create all that is needed for a given domain specified in the `SERVER` environment variable.
For instance in the following we use `localhost`:

```
SERVER=localhost ../../../utils/create_cert.sh
```

This will create the following files:

```
ca.key       # unused
ca.crt       # used by all
server.csr   # unused
server.crt   # used by edgecomputer and edgerouter
server.key   # same
client.csr   # unused
client.crt   # used by edgeclient and edgerouter
client.key   # as above
```

Note that `edgerouter` uses both the client and the server credentials: this is becase it playes the role of a server from the point of view of the `edgeclient`, and it is a client for `edgecomputer`.

## Step-by-step example

We will need four terminals/screens, one for each component.

In the first terminal we run the controller:

```
./edgecontroller
```

In the second terminal we run the lambda function executor, which by default simulates two containers responding to functions `clambda0` and `glambda0`:

```
./edgecomputer \
  --controller localhost:6475 \
  --server-endpoint localhost:20000 \
  --secure
```

In the third terminal we run the edge router, listening on the default end-point `localhost:6473`:

```
./edgerouter --controller localhost:6475 --secure
```

Notes:

- we do not specify a `--secure` flag for `edgecontroller` because it does not handle function call execution, hence all its interactions via gRPC and not authenticated/encrypted
- `edgecomputer` and `edgerouter` (and `edgeclient` below) look for the SSL/TLS credential files into the current directory and they expect they to have the default names, as generated by `create_cert.sh` above. If you want to use different location or file names, this can be done via the following environment variables:
  - `CERT_DIR`: the directory where to search for the certificate and key files
  - `CA_CRT`: name of the file with the root certificate
  - `SERVER_KEY`/`SERVER_CRT`: names of the files with the server key and certificate, respectively
  - `CLIENT_KEY`/`CLIENT_CRT`: names of the files with the clientkey and certificate, respectively

Finally, in the fourth terminal we run the client and issue 5 lambda function requests towards `edgerouter` using the default end-point `localhost:6473`:

```
./edgeclient --max 5 --secure
```

An example output is the following:

```
I20220921 11:55:02.831069 50327 client.cpp:85] created a client with seed (0,0), which will send max 5 requests to localhost:6473, single function mode (clambda0)
W20220921 11:55:02.831277 50327 client.cpp:497] clearing an already empty state server end-point: ignored
0.0699354 0.0676766 0 localhost:20000 clambda0 2
0.0732547 0.00317856 0 localhost:20000 clambda0 2
0.0764815 0.00315431 0 localhost:20000 clambda0 2
0.0798513 0.003296 0 localhost:20000 clambda0 2
0.0831767 0.00325536 0 localhost:20000 clambda0 2
I20220921 11:55:02.912971 50327 edgeclientmain.cpp:341] latency 0.0161122 +- 0.0257823
I20220921 11:55:02.913044 50327 edgeclientmain.cpp:344] processing 0.001 +- 0
```

The latency of the first lambda function execution (about 68 ms) is significantly greater than that of the subsequent ones (about 3 ms), because of the initial handshake.
By running the same example without the `--secure` flag, the start-up latency drops to about 10 ms, with the latenct subsequent calls remaining the same.

## Caveat emptor

- The certificates generated by `create_cert.sh` cover only the domain specified by `SERVER`. If you want to distribute the components over multiple servers, e.g., `a.mydomain.com`, `b.mydomain.com`, etc, then you have to specify `SERVER=*.mydomain.com`. It is not trivial to extend to further scenarios or to implement more sophisticated authentication policies.
- It is not possible to mix secure and non-secure components in the same deployment. The execution of lambda function execution will throw an exception if there is a mismatch. This includes the case of a secure client trying to use a non-secure server.